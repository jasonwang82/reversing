# Claude for Excel & Claude for PowerPoint 技术实现文档

## 一、整体架构

两款插件均以 **Microsoft Office Add-in（Task Pane）** 形式运行，前端使用 OfficeJS（Office JavaScript API）直接操作宿主应用（Excel / PowerPoint）中的文档对象，后端通过 HTTPS 与 Anthropic API 通信。

```
┌────────────────────────────────────────────────────────────────┐
│                      用户设备 / 浏览器                          │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                  Office 应用（Excel / PPT）              │  │
│  │  ┌─────────────────┐  ┌─────────────────────────────┐   │  │
│  │  │   文档（用户数据）│◄►│  Task Pane（WebView/iframe）│   │  │
│  │  └─────────────────┘  │  ┌─────────────────────────┐ │   │  │
│  │         ▲             │  │  OfficeJS 插件 (JS/HTML) │ │   │  │
│  │         │ OfficeJS API│  │  - Office.run() / Excel  │ │   │  │
│  │         │  (in-process│  │  - Chat UI              │ │   │  │
│  │         └─────────────┤  └────────────┬────────────┘ │   │  │
│  └────────────────────── │ ──────────────┼──────────────┘   │  │
└──────────────────────────┼──────────────┼──────────────────── ┘
                           │              │ HTTPS / WebSocket
                           └──────────────┼───────────────────────────┐
                                          │   Anthropic 基础设施        │
                                          ▼                            │
                           ┌─────────────────────────────┐            │
                           │         Orchestrator         │            │
                           │  - 管理对话上下文             │            │
                           │  - 调用 Claude API           │            │
                           │  - 验证/代理工具调用          │            │
                           │  - 监听沙箱 .request 文件     │            │
                           └────────────┬────────────────┘            │
                                        │ (仅 Excel)                  │
                                        ▼                              │
                           ┌─────────────────────────────┐            │
                           │   gVisor 沙箱（Debian 容器） │            │
                           │  - Python 3.11 环境          │            │
                           │  - 无网络访问                 │            │
                           │  - 文件 IPC（.request/.resp）│            │
                           └─────────────────────────────┘            │
                                                                       │
└──────────────────────────────────────────────────────────────────────┘
```

---

## 二、Claude for Excel 技术实现

### 2.1 API 请求结构

**HTTP 端点与头信息：**
```http
POST /v1/messages HTTP/2
Host: api.anthropic.com
Origin: https://pivot.claude.ai
anthropic-version: 2023-06-01
anthropic-beta: oauth-2025-04-20,code-execution-2025-08-25,files-api-2025-04-14,code-execution-with-tools-2025-09-08
anthropic-dangerous-direct-browser-access: true
x-stainless-timeout: 600
```

说明：
- `Origin: https://pivot.claude.ai`：内部项目代号为 **Pivot**
- `anthropic-dangerous-direct-browser-access: true`：允许浏览器端直接调用 API，无需后端代理
- `x-stainless-timeout: 600`：请求超时 10 分钟
- `code-execution-with-tools-2025-09-08`：Anthropic 为 Pivot 内部定制的早期 PTC（Programmatic Tool Calling）beta，比公开 `advanced-tool-use-2025-11-20` 早约 2 个月

**请求体结构：**
```json
{
  "model": "claude-opus-4-5-20251101",
  "max_tokens": 50000,
  "stream": true,
  "container": "container_011CXj1EJg1bFSwXLr4LuboX",
  "metadata": {
    "user_id": "excel-add-in/<base64_encoded_email>"
  },
  "system": "...(system prompt)...",
  "tools": [...],
  "messages": [...]
}
```

- `container` 字段绑定一个持久化的代码执行容器，在同一对话的多个轮次中复用。

### 2.2 用户消息格式

每条用户消息包含多个 content block：

```json
{
  "role": "user",
  "content": [
    { "type": "text", "text": "用户的实际问题或请求" },
    {
      "type": "text",
      "text": "<user_context>\nCurrent active sheet ID: 1\nSelected ranges: Sheet1!A1:B10\n</user_context>"
    },
    {
      "type": "text",
      "text": "<initial_state>\n{\"success\":true,\"fileName\":\"Book1\",\"sheetsMetadata\":[...],\"totalSheets\":1}\n</initial_state>"
    }
  ]
}
```

- `<user_context>`：每次对话轮都会追加，包含当前 sheet ID 和选区
- `<initial_state>`：仅第一条消息包含，包含工作簿元数据（表格列表、尺寸、冻结窗格等）

### 2.3 工具定义（Tools）

所有工具分两类：直接调用（`direct`）和代码执行内可调用（`code_execution_20250825`）：

```json
{
  "name": "get_range_as_csv",
  "description": "READ. Returns CSV string ready for pandas...",
  "input_schema": { ... },
  "allowed_callers": ["direct", "code_execution_20250825"]
}
```

| `allowed_callers` 值 | 含义 |
|----------------------|------|
| `"direct"` | Claude 可直接调用（code execution 之外） |
| `"code_execution_20250825"` | 可在 Python 代码执行环境中通过 `await tool_name(params)` 调用 |

**支持 PTC（从代码中调用）的工具：**
- `get_cell_ranges`
- `get_range_as_csv`
- `set_cell_range`

其余工具（如 `modify_sheet_structure`、`modify_workbook_structure`）仅支持 `direct` 调用。

### 2.4 PTC（Programmatic Tool Calling）机制

PTC 是 Anthropic 的 beta 特性，允许 Python 沙箱代码在执行过程中"暂停"，向客户端请求工具执行，获得结果后再继续执行。

**API 层面的完整交互序列：**

```
Client (OfficeJS)          Anthropic API           Sandbox (Container)
       │                        │                         │
       │  1. POST /messages      │                         │
       │  (tools + code_exec)   │                         │
       │───────────────────────>│                         │
       │                        │  2. 启动容器，运行 Python │
       │                        │────────────────────────>│
       │                        │                         │
       │                        │  3. Python 调用 await   │
       │                        │     tool()，容器暂停     │
       │                        │<────────────────────────│
       │  4. 响应 (tool_use)     │                         │
       │  stop_reason="tool_use"│                         │
       │<───────────────────────│                         │
       │                        │                         │
       │  5. 本地执行工具        │                         │
       │  (OfficeJS → Excel)    │                         │
       │                        │                         │
       │  6. POST /messages      │                         │
       │  (tool_result)         │                         │
       │───────────────────────>│                         │
       │                        │  7. 携带结果恢复容器执行 │
       │                        │────────────────────────>│
       │                        │                         │
       │                        │  8. Python 继续执行      │
       │                        │<────────────────────────│
       │  9. 最终响应            │                         │
       │  (code_execution_result│                         │
       │<───────────────────────│                         │
```

响应体中，来自代码执行的工具调用会携带 `caller.type: "code_execution_20250825"` 字段，将工具调用与父级 code execution block 关联。

### 2.5 Python 沙箱 RPC 机制（pfc.py）

编排器（Orchestrator）在容器启动时注入 `pfc.py`，提供异步函数存根。Python 代码通过以下流程与 Excel 通信：

```
Python 代码
    │
    ▼ await get_range_as_csv({...})
_call_client_tool()
    │
    ├─ 生成 UUID: custom_tool_use_id
    ├─ 写入 /tmp/srvtoolu_xxx/<id>.request
    ├─ 输出 [TOOL_CALL] 信号到 _original_stdout（绕过 stdout 捕获）
    └─ 等待 .response 文件（PFCToolCallRegistry 每 100ms 轮询）
                │
                ▼
        Orchestrator 检测 [TOOL_CALL] 信号
                │
                ▼
        触发 API 层 PTC 暂停，将 tool_use 返回给客户端
                │
                ▼
        OfficeJS 在本地执行 Excel API 调用
                │
                ▼
        结果通过 API continuation 返回
                │
                ▼
        Orchestrator 写入 <id>.response 文件
                │
                ▼
        PFCToolCallRegistry 检测到文件，唤醒 asyncio Future
                │
                ▼
Python 代码继续执行，获得返回值
```

**`pfc.py` 核心类与函数：**

```python
class PFCToolCallRegistry:
    """单例注册表，管理所有待处理的异步工具调用"""

    async def wait_for_response(self, custom_tool_use_id: str) -> None:
        """等待 .response 文件出现（每 100ms 轮询，4.5 分钟超时）"""

    async def _monitor_loop(self):
        """单次扫描目录，批量检查所有待处理调用的 .response 文件"""

async def _call_client_tool(tool_name: str, **kwargs: Any) -> Any:
    """通用 RPC 实现：写请求文件 → 信号 → 等待响应文件 → 返回结果"""

# 各工具的薄包装
async def get_cell_ranges(params: dict) -> str: ...
async def get_range_as_csv(params: dict) -> str: ...
async def set_cell_range(params: dict) -> str: ...
```

**沙箱环境规格：**

| 属性 | 值 |
|------|-----|
| 操作系统 | Debian GNU/Linux 12 (Bookworm) |
| 内核 | 4.4.0 (gVisor/runsc) |
| Python | 3.11 |
| CPU | 4 核（Intel Emerald Rapids） |
| 内存 | 10 GB |
| 容器生命周期 | 5 分钟（RPC 超时 4.5 分钟） |
| 网络 | 无（完全隔离） |

**可用 Python 库：**
- 数据处理：pandas、numpy、scipy
- 电子表格：openpyxl、xlrd、xlsxwriter
- PDF：pdfplumber、tabula-py
- Office：python-docx、python-pptx
- 其他：pyarrow

### 2.6 安全架构（纵深防御）

```
Claude 生成代码
      │
      ▼
沙箱（gVisor，无网络，无 Excel 直接访问）
      │ 写 .request 文件
      ▼
Orchestrator（验证请求合法性）
      │ 通过 API 将 tool_use 暴露给客户端
      ▼
客户端（验证后在本地通过 OfficeJS 执行）
      │ 将 tool_result 发回 API
      ▼
Orchestrator（写 .response 文件）
      │
      ▼
沙箱读取结果，代码继续执行
```

关键安全措施：
1. **本地执行**：所有 Excel 操作通过 OfficeJS 在用户本地执行，Anthropic 服务端无法直接访问电子表格
2. **gVisor 隔离**：Python 容器运行在 gVisor 沙箱中，无 TCP/IP 网络权限，无文件系统逃逸路径
3. **Orchestrator 验证**：每个来自沙箱的 `.request` 文件都经过编排器验证后才转发给客户端
4. **审计日志**：所有工具调用通过 `[TOOL_CALL]` / `[TOOL_RESULT]` 机制写入审计日志
5. **覆盖保护**：`set_cell_range` 默认拒绝覆盖非空单元格，需显式传入 `allow_overwrite: true`

---

## 三、Claude for PowerPoint 技术实现

### 3.1 整体架构差异

与 Excel 版不同，PowerPoint 版**不使用 Python 沙箱和文件 RPC**，而是将 LLM 生成的 JavaScript 代码直接在插件的 Task Pane WebView 中执行——通过 **SES（Secure ECMAScript）沙箱**隔离。

```
Claude (API)
    │
    ▼ 生成 JS 代码（execute_office_js / edit_slide_xml / ...）
OfficeJS 插件 (Task Pane WebView)
    │
    ├─ SES Compartment（隔离执行 JS 代码）
    │     - 限制全局对象（无 Reflect、无 Proxy、无 Compartment）
    │     - 冻结所有内置类型（lockdown()）
    │     - 限制 Object 方法（移除 defineProperty 等危险方法）
    │
    ├─ Context Proxy（权限追踪）
    │     - 深度 Proxy 包装 PowerPoint.RequestContext
    │     - 追踪所有 setter 和 method 调用
    │     - context.sync() 时向用户展示待执行操作，等待确认
    │
    └─ PowerPoint.run() → Office.js API → 本地 PPT 文档
```

### 3.2 SES 沙箱实现

**初始化流程（`initLockdown()`）：**

1. 保存 `Function` 的静态属性（lockdown 会冻结这些）
2. 调用 SES `lockdown()` 冻结所有 JS 内置类型
3. 恢复 Office.js 内部验证函数（`_validateParams` 等）
4. 通过 Proxy 或直接赋值将 Function 静态属性还原

**沙箱编译（`compileSlideCode` / `compileOfficeJsCode`）：**

```typescript
// OOXML 操作沙箱（edit_slide_xml / edit_slide_master / edit_slide_chart）
function compileSlideCode(code: string) {
  const compartment = new Compartment({
    console, Math, Date, DOMParser, XMLSerializer, escapeXml,
    // 明确屏蔽
    Reflect: undefined, Proxy: undefined,
    Compartment: undefined, harden: undefined, lockdown: undefined,
    Object: createSafeObjectGlobal(),  // 移除 defineProperty 等
  });
  return compartment.evaluate("(async function({ zip, markDirty }) { " + code + " })");
}

// Office.js 直接操作沙箱（execute_office_js）
function compileOfficeJsCode(code: string, permissionFn?) {
  const compartment = new Compartment({
    console, Math, Date, DOMParser, XMLSerializer,
    Reflect: undefined, Proxy: undefined,
    Office: createBlockingProxy(Office, BLOCKED_OFFICE_PATHS),
    PowerPoint: createBlockingProxy(PowerPoint, ["run"]),
    pptx: { withSlideZip: ... },  // 允许在 execute_office_js 中做 OOXML 操作
    ...
  });
  const fn = compartment.evaluate("(async function(context) { " + code + " })");
  // 用 Context Proxy 包装 context，启用权限追踪
  return (realContext) => fn(createContextProxy(realContext, [], [], permissionFn));
}
```

### 3.3 Context Proxy（权限追踪）

`createContextProxy()` 对 `PowerPoint.RequestContext` 进行深度代理，实现：

| 操作 | 行为 |
|------|------|
| 访问被屏蔽的方法（如 `ui.openBrowserWindow`）| 抛出 `IllegalAccessError` |
| 调用任何方法 | 记录到 `actions` 数组，标注是否为破坏性操作 |
| 设置被追踪的属性（如 `textRange.text`）| 记录到 `actions` 数组 |
| 调用 `context.sync()` | 弹出权限提示，展示 `actions` 列表，等待用户确认后再执行 |
| 传入复杂对象参数 | 通过 `deepFreeze()` 冻结，防止原型链污染 |

**被标记为破坏性的方法（`DESTRUCTIVE_METHODS`）：** `delete`, `clear`, `deleteAllPreviousItems` 等

**被追踪的 setter（`TRACKED_SETTERS`）：** `text`, `value`, `content`, `html`, `color`, `size`, `bold`, `italic` 等

**被屏蔽的 Context 方法（`BLOCKED_CONTEXT_METHODS`）：** `ui`, `diagnostics`, `telemetry` 等

### 3.4 OOXML 操作工具（withSlideZip）

对于需要精确控制的操作（图表、复杂布局、母版编辑），插件通过以下流程操作 OOXML：

```
withSlideZip(context, slideIndex, callback)
    │
    ├─ 1. 将指定幻灯片导出为 PPTX ZIP（getSelectedSlides / 截取单张）
    │
    ├─ 2. 扫描 ZIP 中的外部引用（extractExternalReferences）
    │       - 过滤 http:// 等外部链接，防止 XXE / SSRF 注入
    │
    ├─ 3. 调用 callback({ zip, markDirty })
    │       - ZIP 中幻灯片始终为 ppt/slides/slide1.xml
    │       - callback 使用 DOMParser/XMLSerializer 编辑 XML
    │       - 调用 markDirty() 标记已修改
    │
    ├─ 4. 如有修改，将 ZIP 导回 PowerPoint
    │       - 过滤外部引用（再次检查）
    │       - 通过 Office.js 替换幻灯片内容
    │
    └─ 5. 清理冗余母版（cleanupSlideMasters）
```

**ZIP 内关键文件：**
| 文件 | 用途 |
|------|------|
| `ppt/slides/slide1.xml` | 幻灯片内容（形状、文本、图表占位符） |
| `ppt/slideMasters/slideMaster1.xml` | 母版形状、背景、文本样式 |
| `ppt/slideLayouts/slideLayoutN.xml` | 各版式的占位符定义 |
| `ppt/theme/theme1.xml` | 主题颜色、字体、效果 |
| `ppt/charts/chartN.xml` | 图表数据与样式 |

### 3.5 工具实现一览

| 工具名称 | 实现函数 | 执行路径 |
|----------|---------|---------|
| `execute_office_js` | `executeOfficeJs()` | SES Compartment → Context Proxy → `PowerPoint.run()` → OfficeJS API |
| `screenshot_slide` | `screenshotSlide()` | `PowerPoint.run()` → `slide.getImageFittingAspect()` → base64 |
| `edit_slide_xml` | `editSlideXml()` | `withSlideZip()` → OOXML DOMParser 编辑 → 导回 |
| `edit_slide_chart` | `editSlideXml()` | 同上（同一实现，不同工具名） |
| `edit_slide_master` | `editSlideMaster()` | `withSlideZip()` → 修改母版/主题 XML → 导回 |
| `duplicate_slide` | `duplicateSlide()` | `slide.copy()` + `moveTo()` + 清理冗余母版 |
| `verify_slides` | `verifySlides()` | 遍历所有幻灯片，检查形状边界溢出和相互重叠 |
| `read_slide_text` | `readSlideText()` | `getTextFrameOrNullObject()` 批量读取文本 |
| `edit_slide_text` | `editSlideText()` | OOXML 层：定位形状 → 修改 `<a:p>` 段落 |

### 3.6 Office Online 兼容处理

Office Online（Web 版）不支持并发的 `Office.run()` 调用，插件对此做了专项处理：

```typescript
// 对 Office Online 串行化所有 Office.run 调用
let onlineRunQueue = Promise.resolve();

function safeOfficeRun(runFn, callback) {
  if (getPlatform() !== "OfficeOnline") {
    return runFn(callback);  // 桌面版：直接执行
  }
  // Online 版：将任务加入串行队列，并加入超时保护（120s）
  const task = onlineRunQueue.catch(() => {}).then(() =>
    Promise.race([
      runFn(callback),
      new Promise((_, reject) => setTimeout(() => reject(new TimeoutError()), 120_000))
    ])
  );
  onlineRunQueue = task.catch(() => {});
  return task;
}
```

### 3.7 安全机制对比

| 机制 | Claude for Excel | Claude for PowerPoint |
|------|------------------|-----------------------|
| 代码隔离 | gVisor 容器（云端 Python） | SES Compartment（本地 JS） |
| 网络隔离 | 容器无网络 | 屏蔽 `ui.openBrowserWindow` 等 |
| 数据访问控制 | Orchestrator 验证 .request 文件 | Context Proxy 追踪所有操作 |
| 用户确认 | 无（操作即执行） | `context.sync()` 前弹出权限提示 |
| 外部引用防护 | N/A | OOXML 导入前过滤外部链接 |
| 超时保护 | 4.5 分钟 RPC 超时 | 90 秒工具超时；120 秒 Online 超时 |
| 原型链污染防护 | N/A | `deepFreeze()` 冻结传入对象 |

---

## 四、两款产品架构对比

| 维度 | Claude for Excel | Claude for PowerPoint |
|------|------------------|-----------------------|
| 代码执行位置 | 云端 Python 容器（gVisor） | 本地 Task Pane WebView（JS） |
| 沙箱技术 | gVisor（内核级隔离） | SES Compartment（JS 语言级隔离） |
| 工具调用方式 | PTC API（代码中 `await tool()`） + 直接 API 调用 | 直接 API 调用（OfficeJS） |
| 与文档的通信 | 文件 IPC → Orchestrator → HTTPS → OfficeJS → 本地 | 直接 OfficeJS（in-process） |
| 文档格式操作 | OfficeJS + 少量 OOXML（图表、数据透视表） | 大量直接 OOXML 操作（布局、母版、图表） |
| 超时限制 | 5 分钟容器生命周期 | 90 秒工具超时 |
| 用户确认流程 | 无额外确认（LLM 判断只读/写入） | `context.sync()` 前权限提示 |
| 模型 | claude-opus-4-5-20251101 | 未公开（使用 Anthropic API） |
| 内部代号 | Pivot | 未公开 |

---

## 五、关键技术细节

### 5.1 为什么 Claude for Excel 使用文件 IPC 而非直接 API 调用？

1. **gVisor 沙箱无网络**：容器内 Python 代码无法发起 TCP/HTTP 请求，文件 I/O 是唯一允许的副作用
2. **安全边界清晰**：每个工具请求都经过 Orchestrator 验证，可强制执行权限策略和速率限制
3. **原生异步支持**：Python asyncio + 文件轮询模式支持并行工具调用（`asyncio.gather()`）
4. **审计可追溯**：`[TOOL_CALL]` / `[TOOL_RESULT]` 日志提供完整操作审计链

### 5.2 为什么 Claude for PowerPoint 使用 SES 而非服务端沙箱？

1. **本地执行低延迟**：PPT 操作不需要穿越网络，JS 代码在本地 WebView 中执行更快
2. **Office.js 原生支持**：PPT 的 OOXML 操作通过本地 Office.js API 更完整
3. **无服务端状态**：无需维护云端容器，架构更简单
4. **SES 足够强**：对于 LLM 生成的相对可信代码，语言级沙箱即可满足需求

### 5.3 `escapeXml` 全局函数

两款产品的 OOXML 操作代码中都暴露了 `escapeXml` 全局函数，防止在 XML 模板字符串中嵌入未转义的特殊字符（`&`, `<`, `>`, `"`, `'`），避免破坏 XML 解析器：

```typescript
function escapeXml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}
```

此外还有 `sanitizeXmlAmpersands()`，作为最后一道防线，修复未被转义的裸 `&` 字符：

```typescript
const BARE_AMPERSAND_RE = /&(?!amp;|lt;|gt;|apos;|quot;|#\d+;|#x[0-9a-fA-F]+;)/g;
function sanitizeXmlAmpersands(xml: string): string {
  return xml.replace(BARE_AMPERSAND_RE, "&amp;");
}
```
